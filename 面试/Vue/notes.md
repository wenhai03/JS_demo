# Vue 3 组件渲染流程
## 组件初始化过程
1. 使用 `createApp` 函数创建 Vue 应用实例。
2. `createApp` 内部创建了 `app` 对象，实现了 `mount` 方法，用于挂载组件。
3. Vue 3 使用 `Proxy` 替代 `Object.defineProperty`，实现响应式系统。

## 模板编译成渲染函数
1. 使用编译器将模板编译成渲染函数，生成 `render` 函数。
2. `render` 函数用于在运行时生成虚拟节点（VNode）。

## 组件的挂载与更新渲染机制
1. 使用 `mount` 方法将组件挂载到 DOM。
2. 当组件的数据变化时，Vue 3 的响应式系统触发重新渲染。
3. 使用 `patch` 函数比较新旧虚拟节点，仅更新变化的部分。




# `nextTick`在哪里使用？原理是？(批处理实现+异步任务)


每次数据变化后会内部调用nextTick将更新操作延迟，将用户的操作延迟到页面更新之后。内部使用了批处理的方案将用户的回调和内部更新维护到了同一个队列中【内部更新的回调，用户自己的写的回调】，稍后会开启一个异步任务（微任务
宏任务），之后批量执行代码。内部采用的是promise.then，mutationObserver，setImmediate,setTimeout（在vue3中不考虑兼容性 所以内部实现就是promise.then）

# Vue中如何进行依赖收集？（观察者模式）
- 依赖收集的目的是，等会数据变化了可以更新视图，如何收集的 每个属性都有一个dep属性、每个对象也都有一个dep属性。每个组件在渲染的过程中都会创建一个渲染watcher（watcher有三种，渲染watcher，计算属性watcher，用户watcher），一个属性可能会有多个watcher，反过来一个watcher有多个dep。
- 当调用取值方法的时候如果有watcher就会将watcher收集起来，等会数据变化后会通知自己对应的dep触发更新调用watcher.update方法。

# 如何理解vue中模板编译原理 （模板编译原理的核心就是 ast -> 生成代码）
- 会将模板变成ast语法树
- 对ast语法树进行优化 标记静态节点 （vue3中模板编译做了哪些优化 patchFlag，blockTree，事件缓存，节点缓存。。。）
- 代码生成 拼接render函数字符串 + new Function + with
- 
# Vue中diff算法原理（大O表示法）
- diff算法是O(n)级别的，采用的是同级比较，内部是深度优先遍历的方式遍历节点
- 节点判断是否是同一个元素，如果是同一个元素，则比对属性比对孩子，如果不是则直接删除老的换成新的
- Vue2中采用了双指针对一些场景做了优化策略（如果是静态节点可以跳过diff算法）
- 头头，尾尾，尾头，头尾进行优化
- 最后乱序比较就是根据老节点创造一个映射表，用新的去里边找能复用的就复用节点（乱序的时候可能中间的顺序是固定的但是都会做一次移动）

Vue 2 中的 diff 算法原理
- 同级比较：Vue 2 的 diff 算法采用同级比较策略，只比较相同级别的节点。
- 深度优先遍历：算法以深度优先的方式遍历虚拟 DOM 树。
- 双指针优化：对于列表更新，Vue 2 使用双指针进行优化，通过同时遍历新旧列表来找差异。
- 静态节点优化：对于静态节点（不会变化的节点），Vue 2 会跳过 diff 算法，直接复用。
- 头头、尾尾、尾头、头尾优化：在更新列表时，Vue 2 会优先考虑头尾添加或删除节点，这样可以减少不必要的移动操作。
- 映射表复用：在乱序更新时，Vue 2 会根据老节点创建映射表，新节点在映射表中查找可以复用的节点。

Vue 3 中的 diff 算法原理
1. blockTree 概念：Vue 3 引入了 blockTree 概念，对于通过模板编译的动态节点，会将 dynamicChildren 组成数组进行直接数组比对，提高性能。
2. 全量比对：如果不能使用 blockTree，则会采用全量比对，类似于 Vue 2 的 diff 算法。
3. 最长递增子序列：Vue 3 在优化移动节点时，采用了最长递增子序列算法，结合贪心、二分查找和前驱节点，实现 O(nlogn) 的时间复杂度。
4. 优化静态提升：Vue 3 进一步提升了静态提升的策略，使得静态节点的识别和处理更加高效。
5. 多态组件缓存：Vue 3 增强了多态组件的缓存策略，通过缓存不同类型的组件实例来提高渲染性能。
6. 碎片化：Vue 3 支持将一个组件的多个子节点作为单独的碎片进行处理，这样可以更细粒度地控制 DOM 更新。
> vue3 里面还有一个blockTree概念，如果是通过模板编译的，会把dynamicChildren组成数组直接数组比对，性能更好，如果不能使用这种方式才采用全量比对（v-for）
> vue3优化移动节点的时候采用了最长递增子序列来实现 贪心+二分查找+前驱节点实现的 O(nlogn)
